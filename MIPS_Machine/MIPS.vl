// File for our code
//
// 4-bit MIPS ALU in Verilog
//
// We need to:
// redesign mux's at gate-level and extend it to 16 bit

module reg_file (rr1,rr2,wr,wd,regwrite,rd1,rd2,clock);

   input [1:0] rr1,rr2,wr;
   input wd;
   input regwrite,clock;
   output [15:0] rd1,rd2;
   wire c1, c2, c3,w0 , w1, w2, w3, regwrite_and_clock;

// registers

   D_flip_flop r1 (wd,c1,q1);
   D_flip_flop r2 (wd,c2,q2);
   D_flip_flop r3 (wd,c3,q3);

// output port

   mux4x1 mux1 (0,q1,q2,q3,rr1,rd1),
          mux2 (0,q1,q2,q3,rr2,rd2);

// input port

   decoder dec(wr[1],wr[0],w3,w2,w1,w0);

   and a (regwrite_and_clock,regwrite,clock);

   and a1 (c1,regwrite_and_clock,w1),
       a2 (c2,regwrite_and_clock,w2),
       a3 (c3,regwrite_and_clock,w3);

endmodule

// Components

module D_flip_flop(D,CLK,Q);
   input D,CLK;
   output Q;
   wire CLK1, Y;
   not  not1 (CLK1,CLK);
   D_latch D1(D,CLK, Y),
           D2(Y,CLK1,Q);
endmodule

module D_latch(D,C,Q);
   input D,C;
   output Q;
   wire x,y,D1,Q1;
   nand nand1 (x,D, C),
        nand2 (y,D1,C),
        nand3 (Q,x,Q1),
        nand4 (Q1,y,Q);
   not  not1  (D1,D);
endmodule

// Code at bottom
//
// module mux4x1(i0,i1,i2,i3,select,y);
//    input i0,i1,i2,i3;
//    input [1:0] select;
//    output y;
//    reg y;
//    always @ (i0 or i1 or i2 or i3 or select)
//             case (select)
//                2'b00: y = i0;
//                2'b01: y = i1;
//                2'b10: y = i2;
//                2'b11: y = i3;
//             endcase
// endmodule

module decoder (S1,S0,D3,D2,D1,D0);
   input S0,S1;
   output D0,D1,D2,D3;

   not n1 (notS0,S0),
       n2 (notS1,S1);

   and a0 (D0,notS1,notS0),
       a1 (D1,notS1,   S0),
       a2 (D2,   S1,notS0),
       a3 (D3,   S1,   S0);
endmodule

module ALU (op,a,b,result,zero);
   input [15:0] a;
   input [15:0] b;
   input [2:0] op;
   output [15:0] result;
   output zero;
   wire c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13,c14,c15,c16;

   ALU1   alu0 (a[0],b[0],op[2],op[1:0],set,op[2],c1,result[0]);
   ALU1   alu1 (a[1],b[1],op[2],op[1:0],0,  c1,   c2,result[1]);
   ALU1   alu2 (a[2],b[2],op[2],op[1:0],0,  c2,   c3,result[2]);
   ALU1   alu3 (a[3],b[3],op[2],op[1:0],0,  c3,   c4,result[3]);
   ALU1   alu4 (a[4],b[4],op[2],op[1:0],0,  c4,   c5,result[4]);
   ALU1   alu5 (a[5],b[5],op[2],op[1:0],0,  c5,   c6,result[5]);
   ALU1   alu6 (a[6],b[6],op[2],op[1:0],0,  c6,   c7,result[6]);
   ALU1   alu7 (a[7],b[7],op[2],op[1:0],0,  c7,   c8,result[7]);
   ALU1   alu8 (a[8],b[8],op[2],op[1:0],0,  c8,   c9,result[8]);
   ALU1   alu9 (a[9],b[9],op[2],op[1:0],0,  c9,   c10,result[9]);
   ALU1   alu10 (a[10],b[10],op[2],op[1:0],0,  c10,   c11,result[10]);
   ALU1   alu11 (a[11],b[11],op[2],op[1:0],0,  c11,   c12,result[11]);
   ALU1   alu12 (a[12],b[12],op[2],op[1:0],0,  c12,   c13,result[12]);
   ALU1   alu13 (a[13],b[13],op[2],op[1:0],0,  c13,   c14,result[13]);
   ALU1   alu14 (a[14],b[14],op[2],op[1:0],0,  c14,   c15,result[14]);
   ALUmsb alu15 (a[15],b[15],op[2],op[1:0],0,  c15,   c16,result[15],set);

   or or1(or01, result[0],result[1]);
   or or2(or23, result[2],result[3]);
   nor nor1(zero,or01,or23);

endmodule


// 1-bit ALU for bits 0-15

module ALU1 (a,b,binvert,op,less,carryin,carryout,result);
   input a,b,less,carryin,binvert;
   input [1:0] op;
   output carryout,result;
   wire sum, a_and_b, a_or_b, b_inv;

   not not1(b_inv, b);
   mux2x1 mux1(b,b_inv,binvert,b1);
   and and1(a_and_b, a, b);
   or or1(a_or_b, a, b);
   fulladder adder1(sum,carryout,a,b1,carryin);
   mux4x1 mux2(a_and_b,a_or_b,sum,less,op[1:0],result);

endmodule


// 1-bit ALU for the most significant bit

module ALUmsb (a,b,binvert,op,less,carryin,carryout,result,sum);
   input a,b,less,carryin,binvert;
   input [1:0] op;
   output carryout,result,sum;
   wire sum, a_and_b, a_or_b, b_inv;

   not not1(b_inv, b);
   mux2x1 mux1(b,b_inv,binvert,b1);
   and and1(a_and_b, a, b);
   or or1(a_or_b, a, b);
   fulladder adder1(sum,carryout,a,b1,carryin);
   mux4x1 mux2(a_and_b,a_or_b,sum,less,op[1:0],result);

endmodule


module halfadder (S,C,x,y);
   input x,y;
   output S,C;

   xor (S,x,y);
   and (C,x,y);
endmodule


module fulladder (S,C,x,y,z);
   input x,y,z;
   output S,C;
   wire S1,D1,D2;

   halfadder HA1 (S1,D1,x,y),
             HA2 (S,D2,S1,z);
   or g1(C,D2,D1);
endmodule


module mux2x1(A,B,select,OUT);
   input A,B,select;
   output OUT;
   reg OUT;
  //  always @ (select or A or B)
  //        if (select == 0) OUT = A;
  //        else OUT = B;
  nand g1 (w1, A, select),
       g2 (w2, select, select),
       g3 (w3, w2, B),
       g4 (OUT, w1, w3);
endmodule

module mux4x1(i0,i1,i2,i3,select,y);
   input i0,i1,i2,i3;
   input [1:0] select;
   output y;
   reg y;
  //  always @ (i0 or i1 or i2 or i3 or select)
  //           case (select)
  //              2'b00: y = i0;
  //              2'b01: y = i1;
  //              2'b10: y = i2;
  //              2'b11: y = i3;
  //           endcase
  not g1 (x0, select[0]),
      g2 (x1, select[1]);
  and g3 (w1, i0, x0, x1),
      g4 (w2, i1, select[0], x1),
      g5 (w3, i2, select[1], x0),
      g6 (w4, i3, select[1], select[0]);
  or  g7 (y, w1, w2, w3, w4);
endmodule

module MainControl (Op,Control);

  input [3:0] Op;
  output reg [5:0] Control;

  always @(Op) case (Op)
    4'b0000: Control <= 6'b101010;  //add
    4'b0001: Control <=	6'b101110;	//sub
    4'b0010: Control <=	6'b101000;	//and
    4'b0011: Control <=	6'b101001;	//or
    4'b0100: Control <=	6'b011010;	//addi
    4'b0111: Control <= 6'b101111;	//slt
  endcase

endmodule

module signextend(A,B);
   input [7:0] A;
   output [15:0] B;
   or	g1(B[0], A[0]),
      g2(B[1], A[1]),
	    g3(B[2], A[2]),
	    g4(B[3], A[3]),
	    g5(B[4], A[4]),
	    g6(B[5], A[5]),
	    g7(B[6], A[6]),
	    g8(B[7], A[7]),
	    g9(B[8], 0),
	    g10(B[9], 0),
	    g11(B[10], 0),
	    g12(B[11], 0),
	    g13(B[12], 0),
	    g14(B[13], 0),
	    g15(B[14], 0),
	    g16(B[15], 0);
endmodule

module instr_reg (Instruction,IR,CLK);
   input [15:0] Instruction;
   input CLK;
   output [15:0] IR;

   D_flip_flop r0(Instruction[0], CLK, IR[0]);
   D_flip_flop r1(Instruction[1], CLK, IR[1]);
   D_flip_flop r2(Instruction[2], CLK, IR[2]);
   D_flip_flop r3(Instruction[3], CLK, IR[3]);
   D_flip_flop r4(Instruction[4], CLK, IR[4]);
   D_flip_flop r5(Instruction[5], CLK, IR[5]);
   D_flip_flop r6(Instruction[6], CLK, IR[6]);
   D_flip_flop r7(Instruction[7], CLK, IR[7]);
   D_flip_flop r8(Instruction[8], CLK, IR[8]);
   D_flip_flop r9(Instruction[9], CLK, IR[9]);
   D_flip_flop r10(Instruction[10], CLK, IR[10]);
   D_flip_flop r11(Instruction[11], CLK, IR[11]);
   D_flip_flop r12(Instruction[12], CLK, IR[12]);
   D_flip_flop r13(Instruction[13], CLK, IR[13]);
   D_flip_flop r14(Instruction[14], CLK, IR[14]);
   D_flip_flop r15(Instruction[15], CLK, IR[15]);

endmodule

module CPU (clock,ALUOut,Instruction);

  input clock;
  input [15:0] Instruction;
  output [15:0] ALUOut,IR;
  reg[15:0] PC;
  reg[15:0] IMemory; //[0:1023];
  wire [15:0] IR,NextPC,A,B,ALUOut,RD2,SignExtend;
  wire [2:0] ALUctl;
  wire [1:0] ALUOp;
  wire [4:0] WR;

// Test Program:
  // initial begin
  //   IMemory[0] = 32'h2009000f;  // addi $t1, $0,  15   ($t1=15)
  //   IMemory[1] = 32'h200a0007;  // addi $t2, $0,  7    ($t2= 7)
  //   IMemory[2] = 32'h012a5824;  // and  $t3, $t1, $t2  ($t3= 7)
  //   IMemory[3] = 32'h012b5022;  // sub  $t2, $t1, $t3  ($t2= 8)
  //   IMemory[4] = 32'h014b5025;  // or   $t2, $t2, $t3  ($t2=15)
  //   IMemory[5] = 32'h016a482a;  // slt  $t1, $t3, $t2  ($t1= 1)
  //   IMemory[6] = 32'h014b482a;  // slt  $t1, $t2, $t3  ($t1= 0)
  // end

  initial PC = 0;

  // assign IR = IMemory[PC>>2];
  instr_reg instr(Instruction, IR, clock);

  assign WR = (RegDst) ? IR[15:11]: IR[20:16]; // RegDst Mux

  assign B  = (ALUSrc) ? SignExtend: RD2; // ALUSrc Mux

  // assign SignExtend = {{16{IR[15]}},IR[15:0]}; // sign extension unit
  signextend signex(IR[7:0],immediate);

  reg_file rf (IR[11:10],IR[9:8],WR,ALUOut,RegWrite,A,RD2,clock);

  alu fetch (3'b010,PC,4,NextPC,Unused);

  alu ex (ALUctl, A, B, ALUOut, Zero);

  MainControl MainCtr (IR[15:12],{RegDst,ALUSrc,MemtoReg,RegWrite,MemWrite,Branch,ALUOp});

  ALUControl ALUCtrl(ALUOp, IR[5:0], ALUctl); // ALU control unit

  always @(negedge clock) begin
    PC <= NextPC;
  end

endmodule

//Test Module
module test ();

  reg clock;
  wire [15:0] WD,IR;

  CPU test_cpu(clock,WD,IR);

  always #1 clock = ~clock;

  initial begin
    $display ("time clock IR       WD");
    $monitor ("%2d   %b     %h %h", $time,clock,IR,WD);
    clock = 1;
   #2 IMemory = 16'b0100000100001111;// addi $t1, $0,  15   ($t1=15)
   #2 IMemory = 16'b0100001000000111;  // addi $t2, $0,  7    ($t2= 7)
   #2 IMemory = 16'b0010011011000000;  // and  $t3, $t1, $t2  ($t3= 7)
   #2 IMemory = 16'b0001100110000000;  // sub  $t2, $t1, $t3  ($t2= 8)
   #2 IMemory = 16'b0011101110000000;  // or   $t2, $t2, $t3  ($t2=15)
   #2 IMemory = 16'b0000101111000000; // add  $t3, $t2, $t3  ($t3= 22)
   #2 IMemory = 16'b0111111001000000;  // slt  $t1, $t3, $t2  ($t1= 0)
   #2 IMemory = 16'b0111101101000000;  // slt  $t1, $t2, $t3  ($t1= 1)

    #12 $finish;
  end

endmodule
